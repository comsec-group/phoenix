#
# This file is part of LiteDRAM.
#
# Copyright (c) 2023 Antmicro <www.antmicro.com>
# SPDX-License-Identifier: BSD-2-Clause

# Python
import logging
# migen
from migen import *
from migen.fhdl import verilog
# Litex
from litedram.DDR5RCD01.RCD_definitions import *
from litedram.DDR5RCD01.RCD_interfaces import *
from litedram.DDR5RCD01.RCD_interfaces_external import *
from litedram.DDR5RCD01.RCD_utils import *


@enum.unique
class RCDAlertModes(enum.IntEnum):
    STATIC = 0
    PULSED = 1


class DDR5RCD01Alert(Module):
    """
    DDR5 RCD01 Alert
    ----------------

    The alert_n signal is generated by this module based on responses from:
        - parity error checkers in channels
        - error statuses in RWs

    The shape of the alert_n signal is controlled by RWs.

    The alert_n signal assertion from parity errors can be:
        - static

        - pulsed
        Pulse width is regulated by table 100
        If both channels assert error, then the pulse is overlapping (reset counter)

    alert_n stays on until "Clear CA Parity Error" Command is set.

    If derror_in_n is asserted, then alert_n is asserted as well, except:
        - DRST_n is asserted

        - the device is in clock stopped power down mode


    Module
    ------
    d - Input : data
    q - Output: data
    ------
    """

    def __init__(self,
                 err_a,
                 err_b,
                 alert_n,
                 if_ctrl,
                 if_config,
                 ):
        # TODO take errors from channel and create a pulse
        # TODO implement control
        # TODO Implementation forces no error
        """
            Table 100 - ALERT_n Pulse Width for Parity Error
            Name | Min | Max

        """
        PULSE_WIDTH_DICT = {
            "DEBUG": {"MIN": 5, "MAX": 7},
            "DDR5-3200": {"MIN": 96, "MAX": 192},
            "DDR5-3600": {"MIN": 108, "MAX": 216},
            "DDR5-4000": {"MIN": 120, "MAX": 240},
            "DDR5-4400": {"MIN": 132, "MAX": 264},
            "DDR5-4800": {"MIN": 144, "MAX": 288},
        }
        # PULSE_WIDTH = PULSE_WIDTH_DICT["DDR5-3200"]["MIN"]
        PULSE_WIDTH = PULSE_WIDTH_DICT["DEBUG"]["MIN"]
        logging.debug("Set PULSE WIDTH = " + str(PULSE_WIDTH))
        pulse_width_counter_w = self.get_counter_width(PULSE_WIDTH_DICT)
        pulse_width_counter = Signal(pulse_width_counter_w)

        start_alert = Signal()

        self.sync += If(
            if_ctrl.alert_n_mode == RCDAlertModes.STATIC,
            If(
                err_a | err_b,
                alert_n.eq(0)
            ).Else(
                alert_n.eq(1)
            )
        ).Elif(
            if_ctrl.alert_n_mode == RCDAlertModes.PULSED,
            If(
                err_a | err_b,
                start_alert.eq(1)
            ).Else(
                start_alert.eq(0)
            ),
            If(
                pulse_width_counter > 0,
                alert_n.eq(0)
            ).Else(
                alert_n.eq(1)
            )
        )

        self.sync += If(
            start_alert,
            pulse_width_counter.eq(PULSE_WIDTH)
        ).Else(
            If(
                pulse_width_counter != 0,
                pulse_width_counter.eq(pulse_width_counter-1),
            )
        )

    def get_counter_width(self, dict):
        max_settings=[]
        for pulse_width_modes in dict.values():
            max_settings.append(list(pulse_width_modes.values()))
        counter_width=max(max(max_settings)).bit_length()
        return counter_width


if __name__ == "__main__":
    NotSupportedException
