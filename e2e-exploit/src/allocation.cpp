#include "allocation.hpp"

#include <fcntl.h>
#include <random>
#include <sys/mman.h>

#include "pagemap.hpp"

#include <cstring>

constexpr std::size_t BLOCK_SIZE = 4UL * 1024 * 1024;
constexpr size_t BLOCK_SHIFT     = 22;
constexpr size_t BLOCK_MASK      = (1ULL << BLOCK_SHIFT) - 1;

allocation::~allocation() {
    if(allocation_ptr) {
        munmap(allocation_ptr, allocation_size);
    }
}

bool allocation::set_4mb_block(void* ptr) {
    allocation_ptr  = ptr;
    allocation_size = BLOCK_SIZE;

    auto virt_base = (uint64_t)allocation_ptr;

    for(size_t offset = 0; offset < allocation_size; offset += BLOCK_SIZE) {
        auto virt = virt_base + offset;
        auto phys = vaddr2paddr(virt);
        virt_phys_mappings.emplace_back((volatile char*)virt, phys);
    }

    return true;
}

uint64_t allocation::virt_to_phys(volatile char* virt) {
    auto virt_page_base = (volatile char*)((uint64_t)virt & ~BLOCK_MASK);
    auto offset         = (uint64_t)virt & BLOCK_MASK;
    for(auto& pair : virt_phys_mappings) {
        if(pair.first == virt_page_base) {
            return pair.second | offset;
        }
    }

    return 0;
}

volatile char* allocation::phys_to_virt(uint64_t phys) {
    auto phys_page_base = phys & ~BLOCK_MASK;
    auto offset         = phys & BLOCK_MASK;
    for(auto& pair : virt_phys_mappings) {
        if(pair.second == phys_page_base) {
            return (volatile char*)((uint64_t)pair.first | offset);
        }
    }

    return nullptr;
}

volatile char* allocation::get_rand_addr() {
    static std::random_device random_device;
    static std::default_random_engine generator(random_device());
    static std::uniform_int_distribution<uint64_t> distribution(0, this->allocation_size - 1);

    return (volatile char*)((uint64_t)allocation_ptr + distribution(generator));
}
