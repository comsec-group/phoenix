#include <functional>

#include "CLI/CLI.hpp"
#include "allocation.hpp"
#include "dram_address.hpp"
#include "hammer.hpp"
#include "hammer/args.hpp"
#include "measurements.hpp"
#include "pagemap.hpp"

#include <cstring>
#include <iostream>
#include <stdexcept>
#include <sys/mman.h>

// Structure to hold measure command parameters
struct measure_params_t {
    int num_rows;
    int num_banks;
    int num_bankgroups;
    int column_stride;
    int reads_per_trefi;
    bool randomize_strides;
};


// Function to set up the measure subcommand
CLI::App* setup_measure_command(CLI::App& app, measure_params_t& params) {
    // -----------------------------------------------------
    // Subcommand: measure
    // -----------------------------------------------------
    auto measure_sub = app.add_subcommand("measure", "Measure activation throughput");

    measure_sub->add_option("-n,--num-rows", params.num_rows, "Number of rows.")->default_val(1500);
    measure_sub
        ->add_option("--num-banks", params.num_banks, "Number of banks per bankgroup.")
        ->default_val(4);
    measure_sub
        ->add_option("--num-bankgroups", params.num_bankgroups, "Number of bankgroups.")
        ->default_val(8);
    measure_sub
        ->add_option("--column-stride", params.column_stride, "Column stride")
        ->default_val(44);
    measure_sub
        ->add_option("--reads-per-trefi", params.reads_per_trefi, "Reads per tREFI")
        ->default_val(130);
    measure_sub
        ->add_flag("--randomize-strides", params.randomize_strides,
                   "Randomize strides for each aggressor pair.")
        ->default_val(false);

    return measure_sub;
}

CLI::App* setup_hammer_command(CLI::App& app, hammer_params_t& params) {
    auto hammer_sub = app.add_subcommand("hammer", "Perform hammer operation");

    hammer_sub
        ->add_option("-n,--num-patterns", params.num_patterns, "Number of hammer patterns. Each pattern hammers four victims double-sided.")
        ->default_val(10);

    hammer_sub->add_option("--core", params.core, "Hammer core")->default_val(5);

    hammer_sub->add_option("--hammer-fn", params.hammer_fn_name,
                           "Hammer function to use {self_sync | seq_sync}");

    hammer_sub
        ->add_option("--num-sync-rows", params.num_sync_rows, "Number of synchronization rows")
        ->default_val(128);

    hammer_sub
        ->add_option("--sync-base-row", params.sync_base_row, "Sync base row")
        ->default_val(1000);

    hammer_sub
        ->add_option("--ref-threshold", params.ref_threshold, "Reference threshold")
        ->default_val(100);

    // ──────────────────────────── fuzz ranges ──────────────────────────────────
    hammer_sub
        ->add_option("--sync-cycles-min", params.sync_min_cycles, "Minimum sync cycle limit")
        ->required();

    hammer_sub
        ->add_option("--sync-cycles-max", params.sync_max_cycles, "Maximum sync cycle limit")
        ->required();

    hammer_sub
        ->add_option("--sync-cycles-step", params.sync_step_cycles, "Step size for sync-cycles fuzzing")
        ->default_val(1000)
        ->check(CLI::PositiveNumber);

    hammer_sub->add_flag("--write-sync-times", params.write_sync_timestamps,
                         "Write sync timestamp pairs to results directory "
                         "(disabled by default)");

    hammer_sub
        ->add_option("--reads-per-trefi-min", params.reads_per_trefi_min, "Minimum reads per tREFI")
        ->required();

    hammer_sub
        ->add_option("--reads-per-trefi-max", params.reads_per_trefi_max, "Maximum reads per tREFI")
        ->required();

    /* ── step size for reads-per-tREFI (must be divisible by 2) ─────────── */
    static const CLI::Validator EvenNumberValidator{
        [](const std::string& v) {
            int n = std::stoi(v);
            return (n % 2 == 0) ? std::string{} // OK
                                  :
                                  std::string{ "value must be divisible by 2" };
        },
        "even number"
    };

    hammer_sub
        ->add_option("--reads-per-trefi-step", params.reads_per_trefi_step, "Step size for reads-per-tREFI fuzzing (even numbers only)")
        ->default_val(2)
        ->check(EvenNumberValidator)
        ->check(CLI::PositiveNumber);
    // ──────────────────────────────────────────────────────────────────────

    hammer_sub
        ->add_flag("-s,--stop", params.stop_on_first_bitflip,
                   "Stop hammering after the first found bit flip")
        ->default_val(false);

    hammer_sub
        ->add_option("--aggressor-row-base-offset",
                     params.aggressor_row_base_offset, "Aggressor row base offset")
        ->default_val(10);

    hammer_sub
        ->add_option("--aggressor-row-base-limit",
                     params.aggressor_row_base_limit, "Aggressor row base limit")
        ->default_val(20);

    hammer_sub
        ->add_option("--aggressor-row-offset-increment",
                     params.aggressor_row_offset_increment, "Aggressor row offset increment")
        ->default_val(4);

    hammer_sub
        ->add_option("--hammer-rounds", params.hammer_rounds, "Hammer rounds")
        ->default_val(128);

    hammer_sub
        ->add_option("--repeatable-hammer-rounds", params.repeatable_hammer_rounds, "Repeatable hammer rounds")
        ->default_val(2 * 128);

    hammer_sub
        ->add_option("--refs-per-hammer", params.refs_per_hammer, "REFs per hammer")
        ->default_val(4 * 8192);

    hammer_sub
        ->add_option("--column-stride", params.column_stride, "Column stride")
        ->default_val(44);

    hammer_sub
        ->add_option("--num-allocations", params.num_allocations, "Number of allocations")
        ->default_val(10);

    hammer_sub
        ->add_option("--num-repeatability-checks", params.num_repeatablity_checks, "Number of repeatability checks")
        ->default_val(5);

    hammer_sub->add_option("--results-path", params.results_path,
                           "Directory where result files will be written "
                           "(created automatically if it doesn’t exist)");

    hammer_sub
        ->add_option("--subchannels", params.subchannels, "Sub-channel indices (e.g. 0 1 2)")
        ->expected(1, -1);

    hammer_sub->add_option("--ranks", params.ranks, "Rank indices (e.g. 0 1)")->expected(1, -1);

    hammer_sub
        ->add_option("--bank-groups", params.bank_groups, "Bank-group indices (e.g. 0 2)")
        ->expected(1, -1);

    hammer_sub
        ->add_option("--banks", params.banks, "Bank indices (e.g. 0 1 2 3)")
        ->expected(1, -1);

    hammer_sub
        ->add_option("--burst-rotate", params.burst_rotate, "Rotate each pattern per bank to the right")
        ->default_val(0)
        ->check(CLI::NonNegativeNumber);

    hammer_sub->add_option("-p,--pattern", params.pattern_name,
                           "Pattern to use {skh_mod128 | skh_mod2608}");

    return hammer_sub;
}


// Function to execute the measure command
void execute_measure_command(measure_params_t& params) {
    std::cout << "Executing measurement..." << std::endl;
    // measure_activation_throughput(params.num_rows, params.num_banks, params.num_bankgroups);
    measure_activation_throughput_hammering(params.reads_per_trefi, params.column_stride,
                                            params.randomize_strides);
    // Implement measurement logic here
}

void configure_unbuffered_output() {
    setvbuf(stdout, nullptr, _IONBF, 0);
    setvbuf(stderr, nullptr, _IONBF, 0);
}

int main(int argc, char* argv[]) {
    printf("[>] Launching PHOENIX ::: PTE EXPLOIT DEMO\n\n");
    printf(
    "PPPPPP    HH   HH    OOOOO    EEEEEEE   NN   NN   IIIII   XX    XX\n"
        "PP   PP   HH   HH   OO   OO   EE        NNN  NN    III     XX  XX\n"
        "PPPPPP    HHHHHHH   OO   OO   EEEEE     NN N NN    III      XXXX\n"
        "PP        HH   HH   OO   OO   EE        NN  NNN    III     XX  XX\n"
        "PP        HH   HH    OOOO0    EEEEEEE   NN   NN   IIIII   XX    XX\n"
        "                                             by COMSEC, ETH Zurich\n"
        "\n");

    CLI::App app{ "Rowhammer" };

    measure_params_t measure_params;
    hammer_params_t hammer_params;

    // Set up subcommands
    auto measure_sub = setup_measure_command(app, measure_params);
    auto hammer_sub  = setup_hammer_command(app, hammer_params);

    CLI11_PARSE(app, argc, argv);

    // rubench_open();

    configure_unbuffered_output();

    if(*measure_sub) {
        execute_measure_command(measure_params);
    } else if(*hammer_sub) {
        // std::cout << hammer_params << '\n';
        hammer(hammer_params);
    } else {
        std::cout << app.help() << "\n";
    }

    // rubench_close();

    return 0;
}
