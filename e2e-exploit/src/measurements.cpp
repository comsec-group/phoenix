#include "measurements.hpp"
#include "dram_address.hpp"
#include "gen_rows.hpp"
#include "lowutils.hpp"
#include <cstring>
#include <functional>
#include <immintrin.h>
#include <iostream>
#include <string>

void measure(const std::string& name, const std::function<uint64_t()>& tsc) {
    constexpr size_t SZ_TS  = 20;
    constexpr size_t SZ_TS2 = SZ_TS - 1;
    uint64_t ts[SZ_TS];
    uint64_t ts2[SZ_TS2];

    std::cout << "====== Measuring " << name << " timer granularity"
              << "===============" << std::endl;
    for(size_t exp_rep = 0; exp_rep < SZ_TS; exp_rep++) {
        memset(ts, 0, SZ_TS * sizeof(uint64_t));
        uint64_t sum = 0;
        for(unsigned long& t : ts) {
            t = tsc();
        }
        for(size_t k = 1; k < SZ_TS; k++) {
            ts2[k - 1] =
                (ts[k] > ts[k - 1]) ? (ts[k] - ts[k - 1]) : (ts[k - 1] - ts[k]);
            sum += ts2[k - 1];
        }
        std::sort(ts2, ts2 + SZ_TS2);
        printf("min: %4lu, max: %4lu, median: %4lu, average: %4lu\n", ts2[0],
               ts2[SZ_TS2 - 1], ts2[SZ_TS2 / 2], sum / SZ_TS2);
    }
    std::cout << "\n";
}

void measure_timer_granularity() {
    auto rdtsc = []() -> uint64_t {
        uint32_t lo, hi;
        asm volatile("rdtsc" : "=a"(lo), "=d"(hi));
        return (static_cast<uint64_t>(hi) << 32) | lo;
    };

    auto lfence_rdtsc = []() -> uint64_t {
        uint32_t lo, hi;
        asm volatile("lfence\n"
                     "rdtsc"
                     : "=a"(lo), "=d"(hi));
        return (static_cast<uint64_t>(hi) << 32) | lo;
    };

    auto rdtscp = []() -> uint64_t {
        uint64_t lo, hi;
        asm volatile("rdtscp\n" : "=a"(lo), "=d"(hi)::"%rcx");
        return (hi << 32) | lo;
    };

    auto rdpru = []() -> uint64_t {
        uint32_t eax, edx;
        uint32_t ecx = 1;                         // ECX = 1 to read APERF
        __asm__ volatile(".byte 0x0F, 0x01, 0xFD" // Opcode for RDPRU
                         : "=a"(eax), "=d"(edx)
                         : "c"(ecx)
                         : "memory");
        return ((uint64_t)edx << 32) | eax;
    };

    measure("rdtsc", rdtsc);
    measure("lfence_rdtsc", lfence_rdtsc);
    measure("rdtscp", rdtscp);
    measure("rdpru", rdpru);
}

void measure_activation_throughput2() {
    for(int col = 0; col < 4096; col += 64) {
        auto row_address     = dram_address(0, 0, 0, 0, 0, col);
        auto row_address_ptr = row_address.to_virt();

        printf("row_address_ptr: %p\n", (void*)row_address_ptr);
    }
}

void measure_activation_throughput_hammering(int reads_per_trefi, int column_stride, bool randomize_strides) {
    std::vector<volatile uint64_t*> test_rows;
    auto dram_addresses =
        create_row_pair_addresses_colstride(0, 0, 0, 0, {10, 12}, reads_per_trefi / 2,
                                            column_stride, randomize_strides);
    for (auto& dram_address : dram_addresses) {
        auto row_address_ptr = dram_address.to_virt();
        test_rows.push_back(reinterpret_cast<volatile uint64_t*>(row_address_ptr));
        std::cout << "Adding DRAM address: " << dram_address.to_string() << ", 0x"
                  << std::hex << (uint64_t)row_address_ptr << std::dec << std::endl;
        *(test_rows.back()) = column_stride;
        _mm_clflushopt((void*)row_address_ptr);
    }

    while(true) {
        for(auto& test_row : test_rows) {
            *test_row;
        }
        for(auto& test_row : test_rows) {
            _mm_clflushopt((void*)test_row);
        }
    }
}

void measure_activation_throughput(const int num_rows, const int num_banks, const int num_bankgroups) {
    const size_t num_rows_total = num_rows * num_banks * num_bankgroups;
    std::vector<volatile uint64_t*> test_rows;
    bool done              = false;
    size_t num_rows_remaining = num_rows_total;
    for(int row = 0; row < num_rows && !done; row++) {
        for(int bg = 0; bg < num_bankgroups && !done; bg++) {
            for(int bk = 0; bk < num_banks; bk++) {
                if(num_rows_remaining <= 0) {
                    done = true;
                    break;
                }
                auto row_address     = dram_address(0, 0, bg, bk, row, 0);
                auto row_address_ptr = row_address.to_virt();
                test_rows.push_back(reinterpret_cast<volatile uint64_t*>(row_address_ptr));
                std::cout << "Adding DRAM address: " << row_address.to_string() << ", 0x"
                          << std::hex << (uint64_t)row_address_ptr << std::dec << std::endl;
                *(test_rows[row]);
                _mm_clflushopt((void*)row_address_ptr);
                num_rows_remaining--;
            }
        }
    }

    std::cout << "Starting to hammer..." << std::endl;

    auto t0 = rdpru();
    _mm_mfence();
    _mm_lfence();

    // 1-64, number of cache lines that go to the same row
    // block size
    // block size 128 size
    // adjacent line prefetcher
    // access random order
    // clflushopt

    while(true) {
        for(auto& test_row : test_rows) {
            *test_row;
            _mm_clflushopt((void*)test_row);
        }
    }


    _mm_mfence();
    _mm_lfence();
    auto t1 = rdpru();

    double duration_ns = static_cast<double>(t1 - t0) / CPU_FREQ_GHZ;
    auto num_trefi     = static_cast<int>(duration_ns / (1 * 3900));

    const uint64_t cycles = t1 - t0;

    printf("Activation throughput test:\n");
    printf("  Elapsed cycles:           %lu\n", cycles);
    printf("  Time elapsed (ns):        %.6f s\n", duration_ns);
    printf("  tREFIs elapsed:           %d\n", num_trefi);
}
