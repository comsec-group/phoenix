#ifndef RUBICON_HPP
#define RUBICON_HPP

#include "hammer/bit_flips.hpp"
#include "hammer/jitted.hpp"

#include <random>
#include <vector> // needed for std::vector

class Rubicon {
    uint64_t alignment{};
    std::mt19937 gen{ std::random_device{}() };

    int fd_spray{ -1 };
    void* file_ptr{ nullptr };

    public:
    Rubicon();

    /// Initializes a memory page with pseudo-random values.
    void restore_page(int* page_ptr);

    std::vector<bit_flip_info_t>
    repeatable_bit_flips(hammer_fn_t hammer_fn,
                         const hammer_pattern_t& pat,
                         int pattern_repetitions,
                         int self_sync_thresh,
                         const std::vector<bit_flip_info_t>& orig_flips,
                         int max_passes);

    std::vector<bit_flip_info_t>
    repeatable_bit_flips_data(hammer_fn_t hammer_fn,
                              const hammer_pattern_t& pat,
                              int pattern_repetitions,
                              int self_sync_thresh,
                              const std::vector<bit_flip_info_t>& orig_flips,
                              int max_passes);

    void open_spraying_file(void* file_target);
    void close_spraying_file();
    int spray_tables();
    void unspray_tables();

    void huge_split(void* sacrificial_page);
    int block_merge(void* target, unsigned order);
    int migratetype_escalation(std::vector<void*>& bait_pages);

    bool is_exploitable(const bit_flip_info_t& bit_flip) const;
    std::vector<bit_flip_info_t>
    filter_exploitable(const std::vector<bit_flip_info_t>& flips) const;

    /// End-to-end attack driver.
    void e2e(hammer_fn_t hammer_fn,
             const hammer_pattern_t& pat,
             int pattern_repetitions,
             int self_sync_thresh,
             const std::vector<volatile char*>& aggressors,
             const std::vector<volatile char*>& sync_rows,
             const std::vector<bit_flip_info_t>& bit_flips,
             int hammer_rounds);
};

#endif // RUBICON_HPP
