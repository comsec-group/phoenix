#include "gen_rows.hpp"
#include "dram_address.hpp"

#include <algorithm>
#include <random>

std::vector<dram_address>
create_sequential_row_addresses(size_t bank_group, size_t bank, size_t base_row, uint64_t num_rows) {
    std::vector<dram_address> addresses;
    addresses.reserve(num_rows);

    for(uint64_t row = base_row; row < base_row + num_rows; row++) {
        dram_address da(0, 0, bank_group, bank, row, 0);
        addresses.push_back(da);
    }
    return addresses;
}

std::vector<dram_address> create_row_pair_addresses_colstride(size_t subchannel,
                                                              size_t rank,
                                                              size_t bank_group,
                                                              size_t bank,
                                                              const std::vector<size_t>& row_pair,
                                                              size_t num_pairs,
                                                              size_t column_stride,
                                                              bool randomize_stride) {
    std::vector<size_t> colstrides;

    for(size_t i = 0; i < num_pairs; i++) {
        uint64_t col = (i * column_stride) % 4096;
        colstrides.push_back(col);
    }

    if(randomize_stride) {
        std::mt19937 gen(9239482935UL); // fixed seed for reproducibility
        std::shuffle(colstrides.begin(), colstrides.end(), gen);
    }

    std::vector<dram_address> addresses;
    addresses.reserve(num_pairs * 2);
    size_t cur_stride = 0;
    for(size_t i = 0; i < num_pairs; i++) {

        for(const auto row : row_pair) {
            auto da = dram_address(subchannel, rank, bank_group, bank, row,
                                   colstrides[cur_stride]);
            addresses.push_back(da);
        }
        cur_stride++;
    }

    return addresses;
}

std::vector<volatile uint64_t*>
convert_addresses_to_virtual(const std::vector<dram_address>& dram_addresses) {
    std::vector<volatile uint64_t*> virtual_addresses;
    virtual_addresses.reserve(dram_addresses.size());

    for(const auto& da : dram_addresses) {
        virtual_addresses.push_back(reinterpret_cast<volatile uint64_t*>(da.to_virt()));
    }

    return virtual_addresses;
}
