#include "asmjit/core/formatter.h"
#include "asmjit/core/jitruntime.h"
#include "asmjit/core/logger.h"
#include "asmjit/x86/x86assembler.h"

#include "args.hpp"
#include "pattern.hpp"
#include "src/hammer.hpp"

#include <memory>
#include <src/gen_rows.hpp>
#include <stdexcept>
#include <vector>

using namespace asmjit;


void hammer_jitted_self_sync(const hammer_pattern_t& pattern,
                             int pattern_repetitions,
                             int self_sync_threshold) {
    const uint64_t pattern_length = pattern.size();
    if(pattern_length == 0)
        throw std::runtime_error("pattern must contain at least one burst");

    // ── 1. Assemble to a fresh CodeHolder ───────────────────────────────
    JitRuntime jit_runtime;
    CodeHolder code;
    code.init(jit_runtime.environment());
    x86::Assembler a{ &code };

    // ── 2. Prologue – callee-saved regs used as loop state ──────────────
    a.push(x86::rbx);
    a.push(x86::rbp);
    a.push(x86::r12);
    a.push(x86::r13);
    a.push(x86::r14);
    a.push(x86::r15);

    a.xor_(x86::r12, x86::r12);           // idx     = 0
    a.xor_(x86::r13, x86::r13);           // prev_ts = 0
    a.mov(x86::rbp, imm(pattern_length)); // burstCount
    a.mov(x86::r14, imm(self_sync_threshold)); // threshold

    Label jumpTable = a.newLabel();
    a.lea(x86::r15, x86::ptr(jumpTable));

    // ── 3. Outer repetition counter (RBX) ───────────────────────────────
    Label loopTop    = a.newLabel();
    Label afterBurst = a.newLabel();
    Label done       = a.newLabel();

    a.mov(x86::rbx, imm(pattern_repetitions));
    a.bind(loopTop);
    a.test(x86::rbx, x86::rbx);
    a.jle(done);

    // ── 4. Timestamp from global_ref_sync(&thread_data, idx) ────────────
    a.xor_(x86::eax, x86::eax);
    a.mov(x86::rax, imm((uint64_t)&global_ref_sync));
    a.call(x86::rax); // RAX = timestamp

    // ── 5. diff / threshold; update R13(prev_ts) & R12(idx) ─────────────
    a.mov(x86::r11, x86::rax);  // cur_ts copy → R11
    a.sub(x86::rax, x86::r13);  // diff = cur - prev_ts
    a.mov(x86::r13, x86::r11);  // prev_ts = cur_ts
    a.xor_(x86::rdx, x86::rdx); // dividend high = 0
    a.idiv(x86::r14);           // q = diff / threshold
    a.add(x86::r12, x86::rax);  // idx += q
    a.add(x86::r12, 1);         // idx += 1

    // ---- idx %= burstCount --------------------------------------------
    a.mov(x86::rax, x86::r12);
    a.xor_(x86::rdx, x86::rdx);
    a.div(x86::rbp); // remainder → RDX
    a.mov(x86::r12, x86::rdx);

    // ── 6. Indirect jump through jump table ─────────────────────────────
    a.mov(x86::r11, x86::qword_ptr(x86::r15, x86::r12, 3));
    a.lfence();
    a.jmp(x86::r11); // → burst[idx]

    // ── 7. One code block per burst ─────────────────────────────────────
    std::vector<Label> burstLabel(pattern_length);
    for(uint64_t i = 0; i < pattern_length; ++i) {
        burstLabel[i] = a.newLabel();
        a.bind(burstLabel[i]);

        for(auto p : convert_addresses_to_virtual(pattern[i])) {
            a.mov(x86::r10, imm((uint64_t)p));
            a.mov(x86::rax, x86::ptr(x86::r10));
            a.clflushopt(x86::ptr(x86::r10));
        }
        a.lfence();
        a.jmp(afterBurst);
    }

    // ── 8. After-burst housekeeping ─────────────────────────────────────
    a.bind(afterBurst);
    a.dec(x86::rbx);
    a.jmp(loopTop);

    // ── 9. Epilogue ─────────────────────────────────────────────────────
    a.bind(done);
    a.pop(x86::r15);
    a.pop(x86::r14);
    a.pop(x86::r13);
    a.pop(x86::r12);
    a.pop(x86::rbp);
    a.pop(x86::rbx);
    a.ret();

    // ── 10. Jump-table data ─────────────────────────────────────────────
    a.bind(jumpTable);
    for(auto& lbl : burstLabel)
        a.embedLabel(lbl);

    // ── 11. Make it callable & run once ─────────────────────────────────
    using hammer_fn_t = void (*)();
    hammer_fn_t fn    = nullptr;
    jit_runtime.add(reinterpret_cast<void**>(&fn), &code);
    sched_yield();
    sched_yield();
    sched_yield();
    sched_yield();
    fn();
    jit_runtime.release(fn);
}

void hammer_jitted_seq_sync(const hammer_pattern_t& pattern,
                            int pattern_repetitions,
                            int self_sync_threshold) {
    const uint64_t pattern_length = pattern.size();
    if(pattern_length == 0)
        throw std::runtime_error("pattern must contain at least one burst");

    JitRuntime jit_runtime;
    CodeHolder code;
    code.init(jit_runtime.environment());
    x86::Assembler a{ &code };

    // ── 1. Prologue ────────────────────────────────────────────────────
    a.push(x86::rbx);
    a.push(x86::rbp);
    a.push(x86::r12);
    a.push(x86::r13); // (still callee-saved, but now unused)
    a.push(x86::r14); // (unused, kept for stack balance)
    a.push(x86::r15);

    a.xor_(x86::r12, x86::r12);           // idx  = 0
    a.mov(x86::rbp, imm(pattern_length)); // burstCount

    Label jumpTable = a.newLabel();
    a.lea(x86::r15, x86::ptr(jumpTable));

    // ── 2. Outer repetition counter ────────────────────────────────────
    Label loopTop    = a.newLabel();
    Label afterBurst = a.newLabel();
    Label done       = a.newLabel();

    a.mov(x86::rbx, imm(pattern_repetitions));
    a.bind(loopTop);
    a.test(x86::rbx, x86::rbx);
    a.jle(done);

    // ── 3. Timestamp pulse (value ignored, still visible to observers) ─
    a.xor_(x86::eax, x86::eax);
    a.mov(x86::rax, imm((uint64_t)&global_ref_sync));
    a.call(x86::rax); // RAX = timestamp (unused)

    // ── 4. idx = (idx + 1) % burstCount ────────────────────────────────
    a.add(x86::r12, 1); // ++idx
    a.mov(x86::rax, x86::r12);
    a.xor_(x86::rdx, x86::rdx);
    a.div(x86::rbp); // RDX = idx % burstCount
    a.mov(x86::r12, x86::rdx);

    // ── 5. Indirect jump to burst[idx] ─────────────────────────────────
    a.mov(x86::r11, x86::qword_ptr(x86::r15, x86::r12, 3));
    a.lfence();
    a.jmp(x86::r11);

    // ── 6. One code block per burst ────────────────────────────────────
    std::vector<Label> burstLabel(pattern_length);
    for(uint64_t i = 0; i < pattern_length; ++i) {
        burstLabel[i] = a.newLabel();
        a.bind(burstLabel[i]);

        for(auto p : convert_addresses_to_virtual(pattern[i])) {
            a.mov(x86::r10, imm((uint64_t)p));
            a.mov(x86::rax, x86::ptr(x86::r10));
            a.clflushopt(x86::ptr(x86::r10));
        }
        a.lfence();
        a.jmp(afterBurst);
    }

    // ── 7. Housekeeping & loop ─────────────────────────────────────────
    a.bind(afterBurst);
    a.dec(x86::rbx);
    a.jmp(loopTop);

    // ── 8. Epilogue ────────────────────────────────────────────────────
    a.bind(done);
    a.pop(x86::r15);
    a.pop(x86::r14);
    a.pop(x86::r13);
    a.pop(x86::r12);
    a.pop(x86::rbp);
    a.pop(x86::rbx);
    a.ret();

    // ── 9. Jump-table data ─────────────────────────────────────────────
    a.bind(jumpTable);
    for(auto& lbl : burstLabel)
        a.embedLabel(lbl);

    // ── 10. Make it callable & run once ────────────────────────────────
    using hammer_fn_t = void (*)();
    hammer_fn_t fn    = nullptr;
    jit_runtime.add(reinterpret_cast<void**>(&fn), &code);
    sched_yield();
    sched_yield();
    sched_yield();
    sched_yield();
    fn();
    jit_runtime.release(fn);
}
