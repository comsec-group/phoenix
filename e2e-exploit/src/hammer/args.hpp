#pragma once

#include <filesystem>
#include <string>
#include <vector>


struct hammer_params_t {
    int num_patterns{};
    int num_sync_rows{};
    int core{};
    int sync_base_row{};
    uint64_t ref_threshold{};
    std::string hammer_fn_name{ "self_sync" };

    /* ── fuzzing range for sync-cycles ──────────────────────────────── */
    int sync_min_cycles{};
    int sync_max_cycles{};
    int sync_step_cycles{ 1000 };
    bool write_sync_timestamps{ false };

    bool stop_on_first_bitflip{};
    int aggressor_row_base_offset{};
    int aggressor_row_base_limit{};
    int aggressor_row_offset_increment{};
    int refs_per_hammer{};
    int hammer_rounds{};
    int repeatable_hammer_rounds{};
    int column_stride{};
    std::string pattern_name{ "skh_mod128" };

    /* ── fuzzing range for reads-per-tREFI ──────────────────────────── */
    int reads_per_trefi_min{};
    int reads_per_trefi_max{};
    int reads_per_trefi_step{ 2 };

    int num_allocations{};
    int num_repeatablity_checks{};

    std::filesystem::path results_path{};

    /* ── banking / topology selectors & rotation ─────────────── */
    std::vector<int> subchannels{};
    std::vector<int> ranks{};
    std::vector<int> bank_groups{};
    std::vector<int> banks{};
    std::size_t burst_rotate{};
};

/* ────────────────────────────────────────────────────────── *
 *  Helper: join a container to comma-separated string       *
 * ────────────────────────────────────────────────────────── */
template <typename Container>
std::string join(const Container& c, std::string_view sep = ", ") {
    std::ostringstream ss;
    bool first = true;
    for(const auto& v : c) {
        if(!first)
            ss << sep;
        first = false;
        ss << v;
    }
    return ss.str();
}

inline std::ostream& operator<<(std::ostream& os, const hammer_params_t& p) {
    constexpr int w = 28; // left-column width

    os << "hammer_params_t {\n"
       << std::left << std::setw(w) << "  num_patterns" << ": " << p.num_patterns << '\n'
       << std::setw(w) << "  num_sync_rows" << ": " << p.num_sync_rows << '\n'
       << std::setw(w) << "  core" << ": " << p.core << '\n' 
       << std::setw(w) << "  hammer" << ": " << p.hammer_fn_name << '\n'
       << std::setw(w) << "  sync_base_row" << ": " << p.sync_base_row << '\n'
       << std::setw(w) << "  ref_threshold" << ": " << p.ref_threshold << '\n'
       << std::setw(w) << "  sync_min_cycles" << ": " << p.sync_min_cycles << '\n'
       << std::setw(w) << "  sync_max_cycles" << ": " << p.sync_max_cycles << '\n'
       << std::setw(w) << "  sync_step_cycles" << ": " << p.sync_step_cycles << '\n'
       << std::setw(w) << "  write_sync_timestamps" << ": " << std::boolalpha
       << p.write_sync_timestamps << '\n' 
       << std::setw(w) << "  stop_on_first_bitflip" << ": "
       << p.stop_on_first_bitflip << '\n'
       << std::setw(w) << "  aggressor_row_base_offset" << ": "
       << p.aggressor_row_base_offset << '\n'
       << std::setw(w) << "  aggressor_row_base_limit" << ": "
       << p.aggressor_row_base_limit << '\n'
       << std::setw(w) << "  aggressor_row_offset_increment" << ": "
       << p.aggressor_row_offset_increment << '\n'
       << std::setw(w) << "  pattern" << ": " << p.pattern_name << '\n'
       << std::setw(w) << "  hammer_rounds: " << p.hammer_rounds << '\n'
       << std::setw(w) << "  repeatable_hammer_rounds: " << p.repeatable_hammer_rounds << '\n'
       << std::setw(w) << "  refs_per_hammer: " << p.refs_per_hammer << '\n'
       << std::setw(w) << "  column_stride" << ": " << p.column_stride << '\n'
       << std::setw(w) << "  reads_per_trefi_min" << ": " << p.reads_per_trefi_min << '\n'
       << std::setw(w) << "  reads_per_trefi_max" << ": " << p.reads_per_trefi_max << '\n'
       << std::setw(w) << "  reads_per_trefi_step" << ": " << p.reads_per_trefi_step << '\n'
       << std::setw(w) << "  num_allocations" << ": " << p.num_allocations << '\n'
       << std::setw(w) << "  num_repeatability_checks" << ": " << p.num_repeatablity_checks << '\n'
       << std::setw(w) << "  results_path" << ": " << p.results_path.string() << '\n'
       << std::setw(w) << "  subchannels" << ": [" << join(p.subchannels) << "]\n"
       << std::setw(w) << "  ranks" << ": [" << join(p.ranks) << "]\n"
       << std::setw(w) << "  bank_groups" << ": [" << join(p.bank_groups) << "]\n"
       << std::setw(w) << "  banks" << ": [" << join(p.banks) << "]\n"
       << std::setw(w) << "  burst_rotate" << ": " << p.burst_rotate << '\n'
       << '}';

    return os;
}

/* ────────────────────────────────────────────────────────── *
 *  Optional: get the dump as std::string                    *
 * ────────────────────────────────────────────────────────── */
inline std::string to_string(const hammer_params_t& p) {
    std::ostringstream oss;
    oss << p;
    return oss.str();
}