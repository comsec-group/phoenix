#include "bit_flips.hpp"

#include "src/dram_address.hpp"

#include <algorithm>
#include <chrono>
#include <cstdint>
#include <emmintrin.h>
#include <fstream>
#include <immintrin.h>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <tuple>
#include <unordered_set>
#include <vector>

// ────────────────────────────────────────────────────────────────────────────────
// Collect bit-flip information one 64-bit word at a time
// ────────────────────────────────────────────────────────────────────────────────
std::vector<bit_flip_info_t> collect_bit_flips(const std::vector<dram_address>& dram_addresses_victims,
                                               const uint64_t data_pattern_victim) {
    std::vector<bit_flip_info_t> found_bitflips;

    // 1) Gather every unique 8-byte-aligned virtual address that belongs to the
    //    supplied victim rows.
    std::unordered_set<uintptr_t> all_victim_vaddrs;
    for(const auto& da : dram_addresses_victims) {
        for(auto vaddr : da.get_vaddrs_whole_row()) {
            auto addr_u = reinterpret_cast<uintptr_t>(vaddr);
            if((addr_u & (alignof(uint64_t) - 1)) == 0) { // ensure 8-byte alignment
                all_victim_vaddrs.insert(addr_u);
            }
        }
    }

    // 2) Examine each candidate word once.
    for(auto vaddr_u : all_victim_vaddrs) {
        auto* vaddr64 = reinterpret_cast<volatile uint64_t*>(vaddr_u);

        // Evict from all cache levels so we read directly from DRAM.
        _mm_clflushopt((void*)vaddr64);
        _mm_mfence();

        // Load the 64-bit word.
        uint64_t corrupted_value = *vaddr64;
        uint64_t flipped_mask    = corrupted_value ^ data_pattern_victim;

        if(flipped_mask != 0) {
            dram_address da =
                dram_address::from_virt(reinterpret_cast<const volatile char*>(vaddr64));

            found_bitflips.push_back(bit_flip_info_t{
                .address = da, .flipped_mask = flipped_mask, .corrupted_value = corrupted_value });
        }

        // Restore the original pattern and flush again.
        *vaddr64 = data_pattern_victim;
        _mm_clflushopt((void*)(vaddr64));
    }

    return found_bitflips;
}

void initialize_data_pattern(const std::vector<dram_address>& dram_addresses_aggs,
                             uint64_t data_pattern) {
    for(const auto& da : dram_addresses_aggs) {
        auto row = da.get_whole_row();

        for(size_t i = 0; i < row.size(); i += 8) {
            if(row[i].column() % 8 == 0) {
                auto vaddr                                   = row[i].to_virt();
                *reinterpret_cast<volatile uint64_t*>(vaddr) = data_pattern;
                _mm_clflushopt(const_cast<void*>(static_cast<const volatile void*>(vaddr)));
            }
        }
    }
}

namespace { // same sort key used elsewhere
auto bitflip_addr_less = [](const bit_flip_info_t& a, const bit_flip_info_t& b) {
    const dram_address& lhs = a.address;
    const dram_address& rhs = b.address;

    return std::make_tuple(lhs.subchannel(), lhs.rank(), lhs.bank_group(),
                           lhs.bank(), lhs.row(), lhs.column()) <
        std::make_tuple(rhs.subchannel(), rhs.rank(), rhs.bank_group(),
                        rhs.bank(), rhs.row(), rhs.column());
};
} // unnamed namespace

bool is_exploitable(const bit_flip_info_t& bf, const uint64_t alignment, const uint64_t page_size) {
    const uint64_t within_bounds =
        !(bf.flipped_mask & (~(alignment - 1) | (page_size - 1)));

    const auto bf_vaddr = reinterpret_cast<uintptr_t>(bf.address.to_virt());
    const bool pte_to_self = !((bf_vaddr ^ bf.corrupted_value) & bf.flipped_mask);

    return within_bounds && pte_to_self;
}

// ─────────────────────────────────────────────────────────────────────────────
//  Append bit-flips to <filename>.csv  (header auto-inserted once)
//
//  Columns:
//    reads_per_trefi,
//    sync_cycles_threshold,
//    row_base_offset,
//    virt_addr,subch,rank,bg,bank,row,col,
//    expected_hex,actual_hex
// ─────────────────────────────────────────────────────────────────────────────
void write_bit_flips_csv(int pattern_id,
                         std::vector<bit_flip_info_t> bit_flips,
                         int reads_per_trefi,
                         int sync_cycles_threshold,
                         int row_base_offset,
                         const std::filesystem::path& filepath) {
    namespace fs = std::filesystem;

    if(bit_flips.empty()) {
        return;
    }

    std::sort(bit_flips.begin(), bit_flips.end(), bitflip_addr_less);

    /* 1. ensure directory exists ----------------------------------------- */
    if(!filepath.empty()) {
        fs::create_directories(filepath.parent_path());
    }

    /* 2. open file for APPEND -------------------------------------------- */
    std::ofstream csv{ filepath, std::ios::out | std::ios::app };
    if(!csv) {
        std::cerr << "[-] Could not open “" << filepath.string() << "” for writing!\n";
        return;
    }

    /* 3. header (only once) ---------------------------------------------- */
    if(csv.tellp() == 0) {
        csv << "pattern_id,reads_per_trefi,"
            << "sync_cycles_threshold,"
            << "row_base_offset,"
            << "virt_addr,subch,rank,bg,bank,row,col,"
            << "flipped_mask_hex,corrupted_hex,exploitable\n";
    }

    /* 4. rows ------------------------------------------------------------- */
    uint64_t alignment = 1ULL << 22;
    uint64_t page_size = 1ULL << 12;
    for(const auto& bf : bit_flips) {
        const dram_address& a = bf.address;
        const auto vaddr      = reinterpret_cast<uintptr_t>(a.to_virt());

        bool exploitable = is_exploitable(bf, alignment, page_size);

        csv << pattern_id << ',' << reads_per_trefi << ',' << sync_cycles_threshold
            << ',' << row_base_offset << ',' << "0x" << std::uppercase << "0x"
            << std::uppercase << std::hex << vaddr << std::dec << ',' // vaddr in hex
            << a.subchannel() << ',' << a.rank() << ',' << a.bank_group() << ','
            << a.bank() << ',' << a.row() << ',' << a.column() << ',' << std::hex
            << std::uppercase << "0x" << std::setw(16) << std::setfill('0')
            << bf.flipped_mask << ',' << "0x" << std::setw(16)
            << bf.corrupted_value << std::dec << ',' // back to decimal
            << static_cast<int>(exploitable)         // 1 = yes, 0 = no
            << '\n';
    }
}

void print_bit_flips_brief(const std::vector<bit_flip_info_t>& bit_flips) {
    if(bit_flips.empty()) {
        std::cout << "[+] No bit-flips detected.\n";
        return;
    }

    std::vector<bit_flip_info_t> sorted = bit_flips;
    std::sort(sorted.begin(), sorted.end(), bitflip_addr_less);

    std::cout << "[+] Found " << sorted.size() << " bit-flips (brief):\n";

    std::size_t flips_in_row = 0;
    dram_address current     = sorted.front().address;

    auto flush = [&](const dram_address& proto) {
        if(!flips_in_row)
            return;
        dram_address row_addr = proto;
        row_addr.m_column     = 0;
        std::cout << row_addr.to_string() << "  " // row key
                  << flips_in_row << '\n';
        flips_in_row = 0;
    };

    for(const auto& bf : sorted) {
        const auto& a = bf.address;
        bool new_row  = a.bank_group() != current.bank_group() ||
            a.bank() != current.bank() || a.row() != current.row();

        if(new_row) {
            flush(current);
            current = a;
        }
        ++flips_in_row;
    }
    flush(current);
}
